{"version":3,"file":"mini-vue.cjs.js","sources":["../src/mini-core/LanguageTranslator.ts","../src/mini-core/Debug.ts","../src/mini-core/index.ts","../node_modules/tslib/tslib.es6.js","../src/reactivity/src/dep.ts","../src/shared/shapeFlags.ts","../src/shared/index.ts","../src/reactivity/src/effect.ts","../src/reactivity/src/baseHandlers.ts","../src/reactivity/src/reactive.ts","../src/reactivity/src/ref.ts","../src/reactivity/src/computed.ts","../src/runtime-core/vnode.ts","../src/runtime-core/h.ts","../src/runtime-core/componentProps.ts","../src/runtime-core/componentSlots.ts","../src/runtime-core/componentEmits.ts","../src/runtime-core/componentPublicInstance.ts","../src/runtime-core/component.ts","../src/runtime-dom/index.ts","../src/runtime-core/scheduler.ts","../src/runtime-core/componentRenderUtils.ts","../src/runtime-core/renderer.ts","../src/runtime-core/createApp.ts","../src/runtime-core/apiInject.ts","../src/runtime-core/helpers/renderSlot.ts"],"sourcesContent":["// LANGUAGE=cn yarn build\n// LANGUAGE 环境变量可以控制打包的语言\n\n// TODO 需要后面扩展 map 即可\nconst c2eMap = {\n  你好: \"hello\",\n  \"调用 patch\": \"call patch function\",\n};\n\nconst e2cMap = {\n  hello: \"你好\",\n};\n\nexport default class LanguageTranslator {\n  private currentLanguage: string;\n  constructor() {\n    this.currentLanguage = process.env.LANGUAGE || \"cn\";\n    // this.currentLanguage = \"en\";\n  }\n\n  private get currentMap(): any {\n    return this.currentLanguage === \"cn\" ? e2cMap : c2eMap;\n  }\n\n  transition(text) {\n    const result = this.currentMap[text];\n    return result ? result : text;\n  }\n}\n","// 使用： debug.mainPath(\"你好\")()\n// 必须使用两个括号，要保证 line 的正确性就得在要显示 line 的地方调用函数\n// console.log 这个函数不可以被封装\nexport default class Debug {\n  private languageTranslator: any;\n  constructor(languageTranslator) {\n    // 文本转换器 for support english\n    this.languageTranslator = languageTranslator;\n  }\n\n  mainPath(text) {\n    return window.console.log.bind(\n      window.console,\n      `%c[ mainPath ] ${this.languageTranslator.transition(text)}`,\n      \"color:red\"\n    );\n  }\n}\n","// 这个文件夹是 mini-vue 库自己专用的\n// 用户无需关心\nimport LanguageTranslator from \"./LanguageTranslator\";\nimport Debug from \"./Debug\";\n\nconst debug = new Debug(new LanguageTranslator());\nwindow.debug = debug;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","// 用于存储所有的 effect 对象\nexport function createDep(effects?) {\n  const dep = new Set(effects);\n  return dep;\n}\n","// 组件的类型\nexport const enum ShapeFlags {\n    // 最后要渲染的 element 类型\n    ELEMENT = 1,\n    // 组件类型\n    STATEFUL_COMPONENT = 1 << 2,\n    // vnode 的 children 为 string 类型\n    TEXT_CHILDREN = 1 << 3,\n    // vnode 的 children 为数组类型\n    ARRAY_CHILDREN = 1 << 4,\n    // vnode 的 children 为 slots 类型\n    SLOTS_CHILDREN = 1 << 5\n  }\n  ","export * from \"./shapeFlags\";\n\nexport const isObject = (val) => {\n  return val !== null && typeof val === \"object\";\n};\n\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n * 把烤肉串命名方式转换成驼峰命名方式\n */\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : \"\"));\n};\n\nexport const extend = Object.assign;\n\nexport function hasChanged(value, oldValue) {\n  return !Object.is(value, oldValue);\n}\n\n/**\n * @private\n * 首字母大写\n */\nexport const capitalize = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\n/**\n * @private\n * 添加 on 前缀，并且首字母大写\n */\nexport const toHandlerKey = (str: string) =>\n  str ? `on${capitalize(str)}` : ``;\n","import { createDep } from \"./dep\";\nimport { extend } from \"../../shared/index\";\n\nlet activeEffect = void 0;\nconst targetMap = new WeakMap();\n\n// 用于依赖收集\nexport class ReactiveEffect {\n  active = true;\n  deps = [];\n  constructor(public fn, public scheduler?) {\n    console.log(\"创建 ReactiveEffect 对象\");\n  }\n\n  run() {\n    // 执行的时候给全局的 activeEffect 赋值\n    // 利用全局属性来获取当前的 effect\n    activeEffect = this as any;\n    // 执行用户传入的 fn\n    console.log(\"执行用户传入的 fn\");\n    return this.fn();\n  }\n\n  stop() {\n    if (this.active) {\n      // 如果第一次执行 stop 后 active 就 false 了\n      // 这是为了防止重复的调用，执行 stop 逻辑\n      cleanupEffect(this);\n      this.active = false;\n    }\n  }\n}\n\nfunction cleanupEffect(effect) {\n  // 找到所有依赖这个 effect 的响应式对象\n  // 从这些响应式对象里面把 effect 给删除掉\n  effect.deps.forEach((dep) => {\n    dep.delete(effect);\n  });\n  effect.deps.length = 0;\n}\n\nexport function effect(fn, options = {}) {\n  const _effect = new ReactiveEffect(fn);\n\n  // 把用户传过来的值合并到 _effect 对象上去\n  // 缺点就是不是显式的，看代码的时候并不知道有什么值\n  extend(_effect, options);\n  _effect.run();\n\n  // 把 _effect.run 这个方法返回\n  // 让用户可以自行选择调用的时机（调用 fn）\n  const runner: any = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\n\nexport function stop(runner) {\n  runner.effect.stop();\n}\n\nexport function track(target, type, key) {\n  console.log(`触发 track -> target: ${target} type:${type} key:${key}`);\n  // 1. 先基于 target 找到对应的 dep\n  // 如果是第一次的话，那么就需要初始化\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // 初始化 depsMap 的逻辑\n    depsMap = new Map();\n    targetMap.set(target, depsMap);\n  }\n\n  let dep = depsMap.get(key);\n\n  if (!dep) {\n    dep = createDep();\n\n    depsMap.set(key, dep);\n  }\n\n  trackEffects(dep);\n}\n\nexport function trackEffects(dep) {\n  // 用 dep 来存放所有的 effect\n  let shouldTrack = false;\n\n  // TODO\n  // 这里是一个优化点\n  // 先看看这个依赖是不是已经收集了，\n  // 已经收集的话，那么就不需要在收集一次了\n  // 可能会影响 code path change 的情况\n  // 需要每次都 cleanupEffect\n  // shouldTrack = !dep.has(activeEffect!);\n\n  // if (!shouldTrack) return;\n  if (!activeEffect) return;\n\n  dep.add(activeEffect);\n  (activeEffect as any).deps.push(dep);\n}\n\nexport function trigger(target, type, key) {\n  // 1. 先收集所有的 dep 放到 deps 里面，\n  // 后面会统一处理\n  let deps: Array<any> = [];\n  // dep\n\n  const depsMap = targetMap.get(target);\n\n  // 暂时只实现了 GET 类型\n  // get 类型只需要取出来就可以\n  const dep = depsMap.get(key);\n\n  // 最后收集到 deps 内\n  deps.push(dep);\n\n  const effects: Array<any> = [];\n  deps.forEach((dep) => {\n    // 这里解构 dep 得到的是 dep 内部存储的 effect\n    effects.push(...dep);\n  });\n  // 这里的目的是只有一个 dep ，这个dep 里面包含所有的 effect\n  // 这里的目前应该是为了 triggerEffects 这个函数的复用\n  triggerEffects(createDep(effects));\n}\n\nexport function isTracking() {\n  return activeEffect !== undefined;\n}\n\nexport function triggerEffects(dep) {\n  // 执行收集到的所有的 effect 的 run 方法\n  for (const effect of dep) {\n    if (effect.scheduler) {\n      // scheduler 可以让用户自己选择调用的时机\n      // 这样就可以灵活的控制调用了\n      // 在 runtime-core 中，就是使用了 scheduler 实现了在 next ticker 中调用的逻辑\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\n","import { ReactiveEffect, track, trigger } from \"./effect\";\nimport {\n  reactive,\n  ReactiveFlags,\n  reactiveMap,\n  readonly,\n  readonlyMap,\n  shallowReadonlyMap,\n} from \"./reactive\";\nimport { isObject } from \"../../shared/index\";\n\nconst get = createGetter();\nconst set = createSetter();\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    const isExistInReactiveMap = () =>\n      key === ReactiveFlags.RAW && receiver === reactiveMap.get(target);\n\n    const isExistInReadonlyMap = () =>\n      key === ReactiveFlags.RAW && receiver === readonlyMap.get(target);\n\n    const isExistInShallowReadonlyMap = () =>\n      key === ReactiveFlags.RAW && receiver === shallowReadonlyMap.get(target);\n\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly;\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly;\n    } else if (\n      isExistInReactiveMap() ||\n      isExistInReadonlyMap() ||\n      isExistInShallowReadonlyMap()\n    ) {\n      return target;\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isObject(res)) {\n      // 把内部所有的是 object 的值都用 reactive 包裹，变成响应式对象\n      // 如果说这个 res 值是一个对象的话，那么我们需要把获取到的 res 也转换成 reactive\n      // res 等于 target[key]\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    // 问题：为什么是 readonly 的时候不做依赖收集呢\n    // readonly 的话，是不可以被 set 的， 那不可以被 set 就意味着不会触发 trigger\n    // 所有就没有收集依赖的必要了\n    if (!isReadonly) {\n      // 在触发 get 的时候进行依赖收集\n      track(target, \"get\", key);\n    }\n    return res;\n  };\n}\n\nfunction createSetter() {\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n\n    // 在触发 set 的时候进行触发依赖\n    trigger(target, \"get\", key);\n\n    return result;\n  };\n}\n\nexport const readonlyHandlers = {\n  get: createGetter(true),\n  set(target, key) {\n    // readonly 的响应式对象不可以修改值\n    console.warn(\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n      target\n    );\n    return true;\n  },\n};\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\n\nexport const shallowReadonlyHandlers = {\n  get: createGetter(true, true),\n  set(target, key) {\n    // readonly 的响应式对象不可以修改值\n    console.warn(\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n      target\n    );\n    return true;\n  },\n};\n","import {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReadonlyHandlers,\n} from \"./baseHandlers\";\n\nexport const reactiveMap = new WeakMap();\nexport const readonlyMap = new WeakMap();\nexport const shallowReadonlyMap = new WeakMap();\n\nexport const enum ReactiveFlags {\n  IS_REACTIVE = \"__v_isReactive\",\n  IS_READONLY = \"__v_isReadonly\",\n  RAW = \"__v_raw\",\n}\n\nexport function reactive(target) {\n  return createReactiveObject(target, reactiveMap, mutableHandlers);\n}\n\nexport function readonly(target) {\n  return createReactiveObject(target, readonlyMap, readonlyHandlers);\n}\n\nexport function shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    shallowReadonlyMap,\n    shallowReadonlyHandlers\n  );\n}\n\nexport function isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nexport function isReadonly(value) {\n  return !!value[ReactiveFlags.IS_READONLY];\n}\n\nexport function isReactive(value) {\n  // 如果 value 是 proxy 的话\n  // 会触发 get 操作，而在 createGetter 里面会判断\n  // 如果 value 是普通对象的话\n  // 那么会返回 undefined ，那么就需要转换成布尔值\n  return !!value[ReactiveFlags.IS_REACTIVE];\n}\n\nexport function toRaw(value) {\n  // 如果 value 是proxy 的话 ,那么直接返回就可以了\n  // 因为会触发 createGetter 内的逻辑\n  // 如果 value 是普通对象的话，\n  // 我们就应该返回普通对象\n  // 只要不是 proxy ，只要是得到的 undefined 的话，那么就一定是普通对象\n  // TODO 这里和源码里面实现的不一样，不确定后面会不会有问题\n  if (!value[ReactiveFlags.RAW]) {\n    return value;\n  }\n\n  return value[ReactiveFlags.RAW];\n}\n\nfunction createReactiveObject(target, proxyMap, baseHandlers) {\n  // 核心就是 proxy\n  // 目的是可以侦听到用户 get 或者 set 的动作\n\n  // 如果命中的话就直接返回就好了\n  // 使用缓存做的优化点\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  const proxy = new Proxy(target, baseHandlers);\n\n  // 把创建好的 proxy 给存起来，\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n","import { trackEffects, triggerEffects, isTracking } from \"./effect\";\nimport { createDep } from \"./dep\";\nimport { isObject, hasChanged } from \"../../shared\";\nimport { reactive } from \"./reactive\";\n\nexport class RefImpl {\n  private _rawValue: any;\n  private _value: any;\n  public dep;\n  public __v_isRef = true;\n\n  constructor(value) {\n    this._rawValue = value;\n    // 看看value 是不是一个对象，如果是一个对象的话\n    // 那么需要用 reactive 包裹一下\n    this._value = convert(value);\n    this.dep = createDep();\n  }\n\n  get value() {\n    // 收集依赖\n    trackRefValue(this);\n    return this._value;\n  }\n\n  set value(newValue) {\n    // 当新的值不等于老的值的话，\n    // 那么才需要触发依赖\n    if (hasChanged(newValue, this._rawValue)) {\n      // 更新值\n      this._value = convert(newValue);\n      this._rawValue = newValue;\n      // 触发依赖\n      triggerRefValue(this);\n    }\n  }\n}\n\nexport function ref(value) {\n  return createRef(value);\n}\n\nfunction convert(value) {\n  return isObject(value) ? reactive(value) : value;\n}\n\nfunction createRef(value) {\n  const refImpl = new RefImpl(value);\n\n  return refImpl;\n}\n\nexport function triggerRefValue(ref) {\n  triggerEffects(ref.dep);\n}\n\nexport function trackRefValue(ref) {\n  if (isTracking()) {\n    trackEffects(ref.dep);\n  }\n}\n\n// 这个函数的目的是\n// 帮助解构 ref\n// 比如在 template 中使用 ref 的时候，直接使用就可以了\n// 例如： const count = ref(0) -> 在 template 中使用的话 可以直接 count\n// 解决方案就是通过 proxy 来对 ref 做处理\n\nconst shallowUnwrapHandlers = {\n  get(target, key, receiver) {\n    // 如果里面是一个 ref 类型的话，那么就返回 .value\n    // 如果不是的话，那么直接返回value 就可以了\n    return unRef(Reflect.get(target, key, receiver));\n  },\n  set(target, key, value, receiver) {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      return (target[key].value = value);\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  },\n};\n\n// 这里没有处理 objectWithRefs 是 reactive 类型的时候\n// TODO reactive 里面如果有 ref 类型的 key 的话， 那么也是不需要调用 ref .value 的 \n// （but 这个逻辑在 reactive 里面没有实现）\nexport function proxyRefs(objectWithRefs) {\n  return new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\n// 把 ref 里面的值拿到\nexport function unRef(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nexport function isRef(value) {\n  return value.__v_isRef;\n}\n","import { createDep } from \"./dep\";\nimport { ReactiveEffect } from \"./effect\";\nimport { trackRefValue, triggerRefValue } from \"./ref\";\n\nexport class ComputedRefImpl {\n  public dep: any;\n  public effect: ReactiveEffect;\n\n  private _dirty: boolean;\n  private _value: void;\n\n  constructor(getter) {\n    this._dirty = true;\n    this.dep = createDep();\n    this.effect = new ReactiveEffect(getter, () => {\n      // scheduler\n      // 只要触发了这个函数说明响应式对象的值发生改变了\n      // 那么就解锁，后续在调用 get 的时候就会重新执行，所以会得到最新的值\n      if (this._dirty) return;\n\n      this._dirty = true;\n      triggerRefValue(this);\n    });\n  }\n\n  get value() {\n    // 收集依赖\n    trackRefValue(this);\n    // 锁上，只可以调用一次\n    // 当数据改变的时候才会解锁\n    // 这里就是缓存实现的核心\n    // 解锁是在 scheduler 里面做的\n    if (this._dirty) {\n      this._dirty = false;\n      // 这里执行 run 的话，就是执行用户传入的 fn\n      this._value = this.effect.run();\n    }\n\n    return this._value;\n  }\n}\n\nexport function computed(getter) {\n  return new ComputedRefImpl(getter);\n}\n","import { ShapeFlags } from \"../shared\";\n\nexport const createVNode = function (\n  type: any,\n  props?: any = {},\n  children?: string | Array<any>\n) {\n  // 注意 type 有可能是 string 也有可能是对象\n  // 如果是对象的话，那么就是用户设置的 options\n  // type 为 string 的时候\n  // createVNode(\"div\")\n  // type 为组件对象的时候\n  // createVNode(App)\n  const vnode = {\n    el: null,\n    component: null,\n    key: props.key || null,\n    type,\n    props,\n    children,\n    shapeFlag: getShapeFlag(type),\n  };\n\n  // 基于 children 再次设置 shapeFlag\n  if (Array.isArray(children)) {\n    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN;\n  } else if (typeof children === \"string\") {\n    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN;\n  }\n\n  normalizeChildren(vnode, children);\n\n  return vnode;\n};\n\nexport function normalizeChildren(vnode, children) {\n  if (typeof children === \"object\") {\n    // 暂时主要是为了标识出 slots_children 这个类型来\n    // 暂时我们只有 element 类型和 component 类型的组件\n    // 所以我们这里除了 element ，那么只要是 component 的话，那么children 肯定就是 slots 了\n    if (vnode.shapeFlag & ShapeFlags.ELEMENT) {\n      // 如果是 element 类型的话，那么 children 肯定不是 slots\n    } else {\n      // 这里就必然是 component 了,\n      vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN;\n    }\n  }\n}\n// 用 symbol 作为唯一标识\nexport const Text = Symbol(\"Text\");\n\n/**\n * @private\n */\nexport function createTextVNode(text: string = \" \") {\n  return createVNode(Text, {}, text);\n}\n\n// 标准化 vnode 的格式\n// 其目的是为了让 child 支持多种格式\nexport function normalizeVNode(child) {}\n\n// 基于 type 来判断是什么类型的组件\nfunction getShapeFlag(type: any) {\n  return typeof type === \"string\"\n    ? ShapeFlags.ELEMENT\n    : ShapeFlags.STATEFUL_COMPONENT;\n}\n","import { createVNode } from \"./vnode\";\nexport const h = (type: string, props: any, children: string | Array<any>) => {\n  return createVNode(type, props, children);\n};\n","export function initProps(instance, rawProps) {\n  console.log(\"initProps\");\n\n  // TODO\n  // 应该还有 attrs 的概念\n  // attrs\n  // 如果组件声明了 props 的话，那么才可以进入 props 属性内\n  // 不然的话是需要存储在 attrs 内\n  // 这里暂时直接赋值给 instance.props 即可\n  instance.props = rawProps;\n}\n","import { ShapeFlags } from \"../shared\";\nexport function initSlots(instance, children) {\n  const { vnode } = instance;\n\n  console.log(\"初始化 slots\");\n\n  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\n    normalizeObjectSlots(children, (instance.slots = {}));\n  }\n}\n\nconst normalizeObjectSlots = (rawSlots, slots) => {\n  for (const key in rawSlots) {\n    const value = rawSlots[key];\n    if (typeof value === \"function\") {\n      // 把这个函数给到slots 对象上存起来\n      // 后续在 renderSlots 中调用\n      // TODO 这里没有对 value 做 normalize，\n      // 默认 slots 返回的就是一个 vnode 对象\n      slots[key] = value;\n    }\n  }\n};\n","import { camelize, toHandlerKey } from \"../shared/index\";\nexport function emit(instance, event: string, ...rawArgs) {\n  // 1. emit 是基于 props 里面的 onXXX 的函数来进行匹配的\n  // 所以我们先从 props 中看看是否有对应的 event handler\n  const props = instance.props;\n  // ex: event -> click 那么这里取的就是 onClick\n  // 让事情变的复杂一点如果是烤肉串命名的话，需要转换成  change-page -> changePage\n  // 需要得到事件名称\n  const handlerName = toHandlerKey(camelize(event));\n  const handler = props[handlerName];\n  if (handler) {\n    handler(...rawArgs);\n  }\n}\n","const publicPropertiesMap = {\n  // 当用户调用 instance.proxy.$emit 时就会触发这个函数\n  // i 就是 instance 的缩写 也就是组件实例对象\n  $emit: (i) => i.emit,\n  $slots: (i) => i.slots,\n  $props: (i) => i.props,\n};\n\n// todo 需要让用户可以直接在 render 函数内直接使用 this 来触发 proxy\nexport const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    // 用户访问 proxy[key]\n    // 这里就匹配一下看看是否有对应的 function\n    // 有的话就直接调用这个 function\n    const { setupState } = instance;\n    console.log(`触发 proxy hook , key -> : ${key}`);\n\n    if (key !== \"$\") {\n      // 说明不是访问 public api\n      // 先检测访问的 key 是否存在于 setupState 中, 是的话直接返回\n      if (key in setupState) {\n        return setupState[key];\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n\n    if (publicGetter) {\n      return publicGetter(instance);\n    }\n  },\n};\n","import { initProps } from \"./componentProps\";\nimport { initSlots } from \"./componentSlots\";\nimport { emit } from \"./componentEmits\";\nimport { PublicInstanceProxyHandlers } from \"./componentPublicInstance\";\nimport { proxyRefs, shallowReadonly } from \"../reactivity/src\";\nexport function createComponentInstance(vnode, parent) {\n  const instance = {\n    type: vnode.type,\n    vnode,\n    next: null, // 需要更新的 vnode，用于更新 component 类型的组件\n    props: {},\n    parent,\n    provides: parent ? parent.provides : {}, //  获取 parent 的 provides 作为当前组件的初始化值 这样就可以继承 parent.provides 的属性了\n    proxy: null,\n    isMounted: false,\n    attrs: {}, // 存放 attrs 的数据\n    slots: {}, // 存放插槽的数据\n    ctx: {}, // context 对象\n    setupState: {}, // 存储 setup 的返回值\n    emit: () => {},\n  };\n\n  // 在 prod 坏境下的 ctx 只是下面简单的结构\n  // 在 dev 环境下会更复杂\n  instance.ctx = {\n    _: instance,\n  };\n\n  // 赋值 emit\n  // 这里使用 bind 把 instance 进行绑定\n  // 后面用户使用的时候只需要给 event 和参数即可\n  instance.emit = emit.bind(null, instance) as any;\n\n  return instance;\n}\n\nexport function setupComponent(instance) {\n  // 1. 处理 props\n  // 取出存在 vnode 里面的 props\n  const { props, children } = instance.vnode;\n  initProps(instance, props);\n  // 2. 处理 slots\n  initSlots(instance, children);\n\n  // 源码里面有两种类型的 component\n  // 一种是基于 options 创建的\n  // 还有一种是 function 的\n  // 这里处理的是 options 创建的\n  // 叫做 stateful 类型\n  setupStatefulComponent(instance);\n}\n\nfunction setupStatefulComponent(instance) {\n  // todo\n  // 1. 先创建代理 proxy\n  console.log(\"创建 proxy\");\n\n  // proxy 对象其实是代理了 instance.ctx 对象\n  // 我们在使用的时候需要使用 instance.proxy 对象\n  // 因为 instance.ctx 在 prod 和 dev 坏境下是不同的\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  // 用户声明的对象就是 instance.type\n  // const Component = {setup(),render()} ....\n  const Component = instance.type;\n  // 2. 调用 setup\n\n  // 调用 setup 的时候传入 props\n  const { setup } = Component;\n  if (setup) {\n    // 设置当前 currentInstance 的值\n    // 必须要在调用 setup 之前\n    setCurrentInstance(instance);\n\n    const setupContext = createSetupContext(instance);\n    // 真实的处理场景里面应该是只在 dev 环境才会把 props 设置为只读的\n    const setupResult =\n      setup && setup(shallowReadonly(instance.props), setupContext);\n\n    setCurrentInstance(null);\n\n    // 3. 处理 setupResult\n    handleSetupResult(instance, setupResult);\n  }\n}\n\nfunction createSetupContext(instance) {\n  console.log(\"初始化 setup context\");\n  return {\n    attrs: instance.attrs,\n    slots: instance.slots,\n    emit: instance.emit,\n    expose: () => {}, // TODO 实现 expose 函数逻辑\n  };\n}\n\nfunction handleSetupResult(instance, setupResult) {\n  // setup 返回值不一样的话，会有不同的处理\n  // 1. 看看 setupResult 是个什么\n  if (typeof setupResult === \"function\") {\n    // 如果返回的是 function 的话，那么绑定到 render 上\n    // 认为是 render 逻辑\n    // setup(){ return ()=>(h(\"div\")) }\n    instance.render = setupResult;\n  } else if (typeof setupResult === \"object\") {\n    // 返回的是一个对象的话\n    // 先存到 setupState 上\n    // 先使用 @vue/reactivity 里面的 proxyRefs\n    // 后面我们自己构建\n    // proxyRefs 的作用就是把 setupResult 对象做一层代理\n    // 方便用户直接访问 ref 类型的值\n    // 比如 setupResult 里面有个 count 是个 ref 类型的对象，用户使用的时候就可以直接使用 count 了，而不需要在 count.value\n    // 这里也就是官网里面说到的自动结构 Ref 类型\n    instance.setupState = proxyRefs(setupResult);\n  }\n\n  finishComponentSetup(instance);\n}\n\nfunction finishComponentSetup(instance) {\n  // 给 instance 设置 render\n\n  // 先取到用户设置的 component options\n  const Component = instance.type;\n\n  if (!instance.render) {\n    // todo\n    // 调用 compile 模块来编译 template\n    // Component.render = compile(Component.template, {\n    //     isCustomElement: instance.appContext.config.isCustomElement || NO\n    //   })\n    instance.render = Component.render;\n  }\n\n  // applyOptions()\n}\n\nfunction applyOptions() {\n  // 兼容 vue2.x\n  // todo\n  // options api\n}\n\nlet currentInstance = {};\n// 这个接口暴露给用户，用户可以在 setup 中获取组件实例 instance\nexport function getCurrentInstance() {\n  return currentInstance;\n}\n\nexport function setCurrentInstance(instance) {\n  currentInstance = instance;\n}\n","// 源码里面这些接口是由 runtime-dom 来实现\n// 这里先简单实现\n// 后面也修改成和源码一样的实现\nexport function hostCreateElement(type) {\n  console.log(\"hostCreateElement\", type);\n  const element = document.createElement(type);\n  return element;\n}\n\nexport function hostCreateText(text) {\n  return document.createTextNode(text);\n}\n\nexport function hostSetText(node, text) {\n  node.nodeValue = text;\n}\n\nexport function hostSetElementText(el, text) {\n  console.log(\"hostSetElementText\", el, text);\n  el.innerText = text;\n}\n\nexport function hostPatchProp(el, key, preValue, nextValue) {\n  // preValue 之前的值\n  // 为了之后 update 做准备的值\n  // nextValue 当前的值\n  console.log(`hostPatchProp 设置属性:${key} 值:${nextValue}`);\n  console.log(`key: ${key} 之前的值是:${preValue}`);\n\n  switch (key) {\n    case \"id\":\n    case \"tId\":\n      if (nextValue === null || nextValue === undefined) {\n        el.removeAttribute(key);\n      } else {\n        el.setAttribute(key, nextValue);\n      }\n      break;\n    case \"onClick\":\n      // todo\n      // 先临时实现 click 事件\n      // 后面应该用 directive 来处理\n      // todo\n      // 需要参考 runtime-dom 的做法\n      // 这里需要额外的处理 nextValue 的值\n      // 因为 nextValue 是一个匿名函数的话，那么对比的时候，肯定2个匿名函数就不一样了\n      // 然后就会注册了2遍事件监听\n      if (preValue) {\n        // 先临时 reset\n        el.removeEventListener(\"click\", preValue);\n      }\n      el.addEventListener(\"click\", nextValue);\n      break;\n  }\n}\n\nexport function hostInsert(child, parent, anchor = null) {\n  console.log(\"hostInsert\");\n  if (anchor) {\n    parent.insertBefore(child, anchor);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\nexport function hostRemove(child) {\n  const parent = child.parentNode;\n  if (parent) {\n    parent.removeChild(child);\n  }\n}\n","const queue: any[] = [];\n\nconst p = Promise.resolve();\nlet isFlushPending = false;\n\nexport function nextTick(fn) {\n  return fn ? p.then(fn) : p;\n}\n\nexport function queueJob(job) {\n  if (!queue.includes(job)) {\n    queue.push(job);\n    // 执行所有的 job\n    queueFlush();\n  }\n}\n\nfunction queueFlush() {\n  // 如果同时触发了两个组件的更新的话\n  // 这里就会触发两次 then （微任务逻辑）\n  // 但是着是没有必要的\n  // 我们只需要触发一次即可处理完所有的 job 调用\n  // 所以需要判断一下 如果已经触发过 nextTick 了\n  // 那么后面就不需要再次触发一次 nextTick 逻辑了\n  if (isFlushPending) return;\n  isFlushPending = true;\n  nextTick(flushJobs);\n}\n\nfunction flushJobs() {\n  isFlushPending = false;\n  let job;\n  while ((job = queue.shift())) {\n    if (job) {\n      job();\n    }\n  }\n}\n","export function shouldUpdateComponent(prevVNode, nextVNode) {\n  const { props: prevProps } = prevVNode;\n  const { props: nextProps } = nextVNode;\n  //   const emits = component!.emitsOptions;\n\n  // 这里主要是检测组件的 props\n  // 核心：只要是 props 发生改变了，那么这个 component 就需要更新\n\n  // 1. props 没有变化，那么不需要更新\n  if (prevProps === nextProps) {\n    return false;\n  }\n  // 如果之前没有 props，那么就需要看看现在有没有 props 了\n  // 所以这里基于 nextProps 的值来决定是否更新\n  if (!prevProps) {\n    return !!nextProps;\n  }\n  // 之前有值，现在没值，那么肯定需要更新\n  if (!nextProps) {\n    return true;\n  }\n\n  // 以上都是比较明显的可以知道 props 是否是变化的\n  // 在 hasPropsChanged 会做更细致的对比检测\n  return hasPropsChanged(prevProps, nextProps);\n}\n\nfunction hasPropsChanged(prevProps, nextProps): boolean {\n  // 依次对比每一个 props.key\n\n  // 提前对比一下 length ，length 不一致肯定是需要更新的\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n\n  // 只要现在的 prop 和之前的 prop 不一样那么就需要更新\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key]) {\n      return true;\n    }\n  }\n  return false;\n}\n","import { ShapeFlags } from \"../shared\";\nimport { createComponentInstance } from \"./component\";\nimport {\n  hostCreateElement,\n  hostSetElementText,\n  hostPatchProp,\n  hostInsert,\n  hostRemove,\n  hostSetText,\n  hostCreateText,\n} from \"../runtime-dom\";\nimport { queueJob } from \"./scheduler\";\nimport { effect } from \"../reactivity/src\";\nimport { setupComponent } from \"./component\";\nimport { Text } from \"./vnode\";\nimport { shouldUpdateComponent } from \"./componentRenderUtils\";\n\nexport const render = (vnode, container) => {\n  debug.mainPath(\"调用 patch\")();\n  patch(null, vnode, container);\n};\n\nfunction patch(n1, n2, container = null, parentComponent = null) {\n  // 基于 n2 的类型来判断\n  // 因为 n2 是新的 vnode\n  const { type, shapeFlag } = n2;\n  switch (type) {\n    case Text:\n      processText(n1, n2, container);\n      break;\n    // 其中还有几个类型比如： static fragment comment\n\n    default:\n      // 这里就基于 shapeFlag 来处理\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        console.log(\"处理 element\");\n        processElement(n1, n2, container);\n      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n        console.log(\"处理 component\");\n        processComponent(n1, n2, container, parentComponent);\n      }\n  }\n}\n\nfunction processText(n1, n2, container) {\n  console.log(\"处理 Text 节点\");\n  if (n1 === null) {\n    // n1 是 null 说明是 init 的阶段\n    // 基于 createText 创建出 text 节点，然后使用 insert 添加到 el 内\n    console.log(\"初始化 Text 类型的节点\");\n    hostInsert((n2.el = hostCreateText(n2.children as string)), container);\n  } else {\n    // update\n    // 先对比一下 updated 之后的内容是否和之前的不一样\n    // 在不一样的时候才需要 update text\n    // 这里抽离出来的接口是 setText\n    // 注意，这里一定要记得把 n1.el 赋值给 n2.el, 不然后续是找不到值的\n    const el = (n2.el = n1.el!);\n    if (n2.children !== n1.children) {\n      console.log(\"更新 Text 类型的节点\");\n      hostSetText(el, n2.children as string);\n    }\n  }\n}\n\nfunction processElement(n1, n2, container) {\n  if (!n1) {\n    mountElement(n2, container);\n  } else {\n    // todo\n    updateElement(n1, n2, container);\n  }\n}\n\nfunction updateElement(n1, n2, container) {\n  const oldProps = (n1 && n1.props) || {};\n  const newProps = n2.props || {};\n  // 应该更新 element\n  console.log(\"应该更新 element\");\n  console.log(\"旧的 vnode\", n1);\n  console.log(\"新的 vnode\", n2);\n\n  // 需要把 el 挂载到新的 vnode\n  const el = (n2.el = n1.el);\n\n  // 对比 props\n  patchProps(el, oldProps, newProps);\n\n  // 对比 children\n  patchChildren(n1, n2, el);\n}\n\nfunction patchProps(el, oldProps, newProps) {\n  // 对比 props 有以下几种情况\n  // 1. oldProps 有，newProps 也有，但是 val 值变更了\n  // 举个栗子\n  // 之前: oldProps.id = 1 ，更新后：newProps.id = 2\n\n  // key 存在 oldProps 里 也存在 newProps 内\n  // 以 newProps 作为基准\n  for (const key in newProps) {\n    const prevProp = oldProps[key];\n    const nextProp = newProps[key];\n    if (prevProp !== nextProp) {\n      // 对比属性\n      // 需要交给 host 来更新 key\n      hostPatchProp(el, key, prevProp, nextProp);\n    }\n  }\n\n  // 2. oldProps 有，而 newProps 没有了\n  // 之前： {id:1,tId:2}  更新后： {id:1}\n  // 这种情况下我们就应该以 oldProps 作为基准，因为在 newProps 里面是没有的 tId 的\n  // \b还需要注意一点，如果这个 key 在 newProps 里面已经存在了，说明已经处理过了，就不要在处理了\n  for (const key in oldProps) {\n    const prevProp = oldProps[key];\n    const nextProp = null;\n    if (!(key in newProps)) {\n      // 这里是以 oldProps 为基准来遍历，\n      // 而且得到的值是 newProps 内没有的\n      // 所以交给 host 更新的时候，把新的值设置为 null\n      hostPatchProp(el, key, prevProp, nextProp);\n    }\n  }\n}\n\nfunction patchChildren(n1, n2, container) {\n  const { shapeFlag: prevShapeFlag, children: c1 } = n1;\n  const { shapeFlag, children: c2 } = n2;\n\n  // 如果 n2 的 children 是 text 类型的话\n  // 就看看和之前的 n1 的 children 是不是一样的\n  // 如果不一样的话直接重新设置一下 text 即可\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    if (c2 !== c1) {\n      console.log(\"类型为 text_children, 当前需要更新\");\n      hostSetElementText(container, c2 as string);\n    }\n  } else {\n    // 如果之前是 array_children\n    // 现在还是 array_children 的话\n    // 那么我们就需要对比两个 children 啦\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        patchKeyedChildren(c1, c2, container);\n      }\n    }\n  }\n}\n\nfunction patchKeyedChildren(c1: any[], c2: any[], container) {\n  let i = 0;\n  let e1 = c1.length - 1;\n  let e2 = c2.length - 1;\n\n  const isSameVNodeType = (n1, n2) => {\n    return n1.type === n2.type && n1.key === n2.key;\n  };\n\n  while (i <= e1 && i <= e2) {\n    const prevChild = c1[i];\n    const nextChild = c2[i];\n\n    if (!isSameVNodeType(prevChild, nextChild)) {\n      console.log(\"两个 child 不相等(从左往右比对)\");\n      console.log(`prevChild:${prevChild}`);\n      console.log(`nextChild:${nextChild}`);\n      break;\n    }\n\n    console.log(\"两个 child 相等，接下来对比着两个 child 节点(从左往右比对)\");\n    patch(prevChild, nextChild, container);\n    i++;\n  }\n\n  while (i <= e1 && i <= e2) {\n    // 从右向左取值\n    const prevChild = c1[e1];\n    const nextChild = c2[e2];\n\n    if (!isSameVNodeType(prevChild, nextChild)) {\n      console.log(\"两个 child 不相等(从右往左比对)\");\n      console.log(`prevChild:${prevChild}`);\n      console.log(`nextChild:${nextChild}`);\n      break;\n    }\n    console.log(\"两个 child 相等，接下来对比着两个 child 节点(从右往左比对)\");\n    patch(prevChild, nextChild, container);\n    e1--;\n    e2--;\n  }\n\n  if (i > e1 && i <= e2) {\n    // 如果是这种情况的话就说明 e2 也就是新节点的数量大于旧节点的数量\n    // 也就是说新增了 vnode\n    // 应该循环 c2\n    while (i <= e2) {\n      console.log(`需要新创建一个 vnode: ${c2[i].key}`);\n      patch(null, c2[i], container);\n      i++;\n    }\n  } else if (i > e2 && i <= e1) {\n    // 这种情况的话说明新节点的数量是小于旧节点的数量的\n    // 那么我们就需要把多余的\n    while (i <= e1) {\n      console.log(`需要删除当前的 vnode: ${c1[i].key}`);\n      hostRemove(c1[i].el);\n      i++;\n    }\n  } else {\n    // 左右两边都比对完了，然后剩下的就是中间部位顺序变动的\n    // 例如下面的情况\n    // a,b,[c,d,e],f,g\n    // a,b,[e,c,d],f,g\n\n    let s1 = i;\n    let s2 = i;\n    const keyToNewIndexMap = new Map();\n    // 先把 key 和 newIndex 绑定好，方便后续基于 key 找到 newIndex\n    for (let i = s2; i <= e2; i++) {\n      const nextChild = c2[i];\n      keyToNewIndexMap.set(nextChild.key, i);\n    }\n\n    // 需要处理新节点的数量\n    const toBePatched = e2 - s2 + 1;\n    const newIndexToOldIndexMap = new Array(toBePatched);\n    for (let index = 0; index < newIndexToOldIndexMap.length; index++) {\n      // 源码里面是用 0 来初始化的\n      // 但是有可能 0 是个正常值\n      // 我这里先用 -1 来初始化\n      newIndexToOldIndexMap[index] = -1;\n    }\n    // 遍历老节点\n    // 1. 需要找出老节点有，而新节点没有的 -> 需要把这个节点删除掉\n    // 2. 新老节点都有的，—> 需要 patch\n    for (i = s1; i <= e1; i++) {\n      const prevChild = c1[i];\n      const newIndex = keyToNewIndexMap.get(prevChild.key);\n      newIndexToOldIndexMap[newIndex] = i;\n\n      // 因为有可能 nextIndex 的值为0（0也是正常值）\n      // 所以需要通过值是不是 undefined 来判断\n      // 不能直接 if(newIndex) 来判断\n      if (newIndex === undefined) {\n        // 当前节点的key 不存在于 newChildren 中，需要把当前节点给删除掉\n        hostRemove(prevChild.el);\n      } else {\n        // 新老节点都存在\n        console.log(\"新老节点都存在\");\n        patch(prevChild, c2[newIndex], container);\n      }\n    }\n\n    // 遍历新节点\n    // 1. 需要找出老节点没有，而新节点有的 -> 需要把这个节点创建\n    // 2. 最后需要移动一下位置，比如 [c,d,e] -> [e,c,d]\n    for (i = e2; i >= s2; i--) {\n      const nextChild = c2[i];\n\n      if (newIndexToOldIndexMap[i] === -1) {\n        // 说明是个新增的节点\n        patch(null, c2[i], container);\n      } else {\n        // 有可能 i+1 没有元素 没有的话就直接设置为 null\n        // 在 hostInsert 函数内如果发现是 null 的话，会直接添加到父级容器内\n        const anchor = i + 1 >= e2 + 1 ? null : c2[i + 1];\n        hostInsert(nextChild.el, container, anchor && anchor.el);\n      }\n    }\n  }\n}\n\nfunction mountElement(vnode, container) {\n  const { shapeFlag, props } = vnode;\n  // 1. 先创建 element\n  // 基于可扩展的渲染 api\n  const el = (vnode.el = hostCreateElement(vnode.type));\n\n  // 支持单子组件和多子组件的创建\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    // 举个栗子\n    // render(){\n    //     return h(\"div\",{},\"test\")\n    // }\n    // 这里 children 就是 test ，只需要渲染一下就完事了\n    console.log(`处理文本:${vnode.children}`);\n    hostSetElementText(el, vnode.children);\n  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n    // 举个栗子\n    // render(){\n    // Hello 是个 component\n    //     return h(\"div\",{},[h(\"p\"),h(Hello)])\n    // }\n    // 这里 children 就是个数组了，就需要依次调用 patch 递归来处理\n    mountChildren(vnode.children, el);\n  }\n\n  // 处理 props\n  if (props) {\n    for (const key in props) {\n      // todo\n      // 需要过滤掉vue自身用的key\n      // 比如生命周期相关的 key: beforeMount、mounted\n      const nextVal = props[key];\n      hostPatchProp(el, key, null, nextVal);\n    }\n  }\n\n  // todo\n  // 触发 beforeMount() 钩子\n  console.log(\"vnodeHook  -> onVnodeBeforeMount\");\n  console.log(\"DirectiveHook  -> beforeMount\");\n  console.log(\"transition  -> beforeEnter\");\n\n  // 插入\n  hostInsert(el, container);\n\n  // todo\n  // 触发 mounted() 钩子\n  console.log(\"vnodeHook  -> onVnodeMounted\");\n  console.log(\"DirectiveHook  -> mounted\");\n  console.log(\"transition  -> enter\");\n}\n\nfunction mountChildren(children, container) {\n  children.forEach((VNodeChild) => {\n    // todo\n    // 这里应该需要处理一下 vnodeChild\n    // 因为有可能不是 vnode 类型\n    console.log(\"mountChildren:\", VNodeChild);\n    patch(null, VNodeChild, container);\n  });\n}\n\nfunction processComponent(n1, n2, container, parentComponent) {\n  // 如果 n1 没有值的话，那么就是 mount\n  if (!n1) {\n    // 初始化 component\n    mountComponent(n2, container, parentComponent);\n  } else {\n    updateComponent(n1, n2, container);\n  }\n}\n\n// 组件的更新\nfunction updateComponent(n1, n2, container) {\n  console.log(\"更新组件\", n1, n2);\n  // 更新组件实例引用\n  const instance = (n2.component = n1.component);\n  // 先看看这个组件是否应该更新\n  if (shouldUpdateComponent(n1, n2)) {\n    console.log(`组件需要更新: ${instance}`);\n    // 那么 next 就是新的 vnode 了（也就是 n2）\n    instance.next = n2;\n    // 这里的 update 是在 setupRenderEffect 里面初始化的，update 函数除了当内部的响应式对象发生改变的时候会调用\n    // 还可以直接主动的调用(这是属于 effect 的特性)\n    // 调用 update 再次更新调用 patch 逻辑\n    // 在update 中调用的 next 就变成了 n2了\n    // ps：可以详细的看看 update 中 next 的应用\n    // TODO 需要在 update 中处理支持 next 的逻辑\n    instance.update();\n  } else {\n    console.log(`组件不需要更新: ${instance}`);\n    // 不需要更新的话，那么只需要覆盖下面的属性即可\n    n2.component = n1.component;\n    n2.el = n1.el;\n    instance.vnode = n2;\n  }\n}\n\nfunction mountComponent(initialVNode, container, parentComponent) {\n  // 1. 先创建一个 component instance\n  const instance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent\n  ));\n  console.log(`创建组件实例:${instance.type.name}`);\n  // 2. 给 instance 加工加工\n  setupComponent(instance);\n\n  setupRenderEffect(instance, container);\n}\n\nfunction setupRenderEffect(instance, container) {\n  // 调用 render\n  // 应该传入 ctx 也就是 proxy\n  // ctx 可以选择暴露给用户的 api\n  // 源代码里面是调用的 renderComponentRoot 函数\n  // 这里为了简化直接调用 render\n\n  // obj.name  = \"111\"\n  // obj.name = \"2222\"\n  // 从哪里做一些事\n  // 收集数据改变之后要做的事 (函数)\n  // 依赖收集   effect 函数\n  // 触发依赖\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 组件初始化的时候会执行这里\n      // 为什么要在这里调用 render 函数呢\n      // 是因为在 effect 内调用 render 才能触发依赖收集\n      // 等到后面响应式的值变更后会再次触发这个函数\n      console.log(\"调用 render,获取 subTree\");\n      const proxyToUse = instance.proxy;\n      // 可在 render 函数中通过 this 来使用 proxy\n      const subTree = (instance.subTree = instance.render.call(\n        proxyToUse,\n        proxyToUse\n      ));\n      console.log(\"subTree\", subTree);\n\n      // todo\n      console.log(`${instance.type.name}:触发 beforeMount hook`);\n      console.log(`${instance.type.name}:触发 onVnodeBeforeMount hook`);\n\n      // 这里基于 subTree 再次调用 patch\n      // 基于 render 返回的 vnode ，再次进行渲染\n      // 这里我把这个行为隐喻成开箱\n      // 一个组件就是一个箱子\n      // 里面有可能是 element （也就是可以直接渲染的）\n      // 也有可能还是 component\n      // 这里就是递归的开箱\n      // 而 subTree 就是当前的这个箱子（组件）装的东西\n      // 箱子（组件）只是个概念，它实际是不需要渲染的\n      // 要渲染的是箱子里面的 subTree\n      patch(null, subTree, container, instance);\n\n      console.log(`${instance.type.name}:触发 mounted hook`);\n      instance.isMounted = true;\n    } else {\n    }\n    // 响应式的值变更后会从这里执行逻辑\n    // 主要就是拿到新的 vnode ，然后和之前的 vnode 进行对比\n    console.log(\"调用更新逻辑\");\n    // 拿到最新的 subTree\n    const { next, vnode } = instance;\n\n    // 如果有 next 的话， 说明需要更新组件的数据（props，slots 等）\n    // 先更新组件的数据，然后更新完成后，在继续对比当前组件的子元素\n    if (next) {\n      next.el = vnode.el;\n      updateComponentPreRender(instance, next);\n    }\n\n    const proxyToUse = instance.proxy;\n    const nextTree = instance.render.call(proxyToUse, proxyToUse);\n    // 替换之前的 subTree\n    const prevTree = instance.subTree;\n    instance.subTree = nextTree;\n\n    // 触发 beforeUpdated hook\n    console.log(\"beforeUpdated hook\");\n    console.log(\"onVnodeBeforeUpdate hook\");\n\n    // 用旧的 vnode 和新的 vnode 交给 patch 来处理\n    patch(prevTree, nextTree, prevTree.el, instance);\n\n    // 触发 updated hook\n    console.log(\"updated hook\");\n    console.log(\"onVnodeUpdated hook\");\n  }\n\n  // 在 vue3.2 版本里面是使用的 new ReactiveEffect\n  // 至于为什么不直接用 effect ，是因为需要一个 scope  参数来收集所有的 effect\n  // 而 effect 这个函数是对外的 api ，是不可以轻易改变参数的，所以会使用  new ReactiveEffect\n  // 因为 ReactiveEffect 是内部对象，加一个参数是无所谓的\n  // 后面如果要实现 scope 的逻辑的时候 需要改过来\n  // 现在就先算了\n  instance.update = effect(componentUpdateFn, {\n    scheduler: () => {\n      // 把 effect 推到微任务的时候在执行\n      // queueJob(effect);\n      queueJob(instance.update);\n    },\n  });\n}\n\nfunction updateComponentPreRender(instance, nextVNode) {\n  const { props } = nextVNode;\n  console.log(\"更新组件的 props\", props);\n  instance.props = props;\n  console.log(\"更新组件的 slots\");\n  // TODO 更新组件的 slots\n}\n","import { render } from \"./renderer\";\nimport { createVNode } from \"./vnode\";\n\n// createApp\n// 在 vue3 里面 createApp 是属于 renderer 对象的\n// 而 renderer 对象需要创建\n// 这里我们暂时不实现\n\nexport const createApp = (rootComponent) => {\n  const app = {\n    _component: rootComponent,\n    mount(rootContainer) {\n      console.log(\"基于根组件创建 vnode\");\n      const vnode = createVNode(rootComponent);\n      console.log(\"调用 render，基于 vnode 进行开箱\");\n      render(vnode, rootContainer);\n    },\n  };\n\n  return app;\n};\n","import { getCurrentInstance } from \"./component\";\n\nexport function provide(key, value) {\n  const currentInstance = getCurrentInstance();\n\n  if (currentInstance) {\n    let { provides } = currentInstance;\n\n    const parentProvides = currentInstance.parent?.provides;\n\n    // 这里要解决一个问题\n    // 当父级 key 和 爷爷级别的 key 重复的时候，对于子组件来讲，需要取最近的父级别组件的值\n    // 那这里的解决方案就是利用原型链来解决\n    // provides 初始化的时候是在 createComponent 时处理的，当时是直接把 parent.provides 赋值给组件的 provides 的\n    // 所以，如果说这里发现 provides 和 parentProvides 相等的话，那么就说明是第一次做 provide(对于当前组件来讲)\n    // 我们就可以把 parent.provides 作为 currentInstance.provides 的原型重新赋值\n    // 至于为什么不在 createComponent 的时候做这个处理，可能的好处是在这里初始化的话，是有个懒执行的效果（优化点，只有需要的时候在初始化）\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n\n    provides[key] = value;\n  }\n}\n\nexport function inject(key, defaultValue) {\n  const currentInstance = getCurrentInstance();\n\n  if (currentInstance) {\n    const provides = currentInstance.parent?.provides;\n\n    if (key in provides) {\n      return provides[key];\n    } else if (defaultValue) {\n      if (typeof defaultValue === \"function\") {\n        return defaultValue();\n      }\n      return defaultValue;\n    }\n  }\n}\n","import { getCurrentInstance } from \"../component\";\n\n/**\n * Compiler runtime helper for rendering `<slot/>`\n * 用来 render slot 的\n * 之前是把 slot 的数据都存在 instance.slots 内(可以看 componentSlot.ts)，\n * 这里就是取数据然后渲染出来的点\n * 这个是由 compiler 模块直接渲染出来的 -可以参看这个 demo https://vue-next-template-explorer.netlify.app/#%7B%22src%22%3A%22%3Cdiv%3E%5Cn%20%20%3Cslot%3E%3C%2Fslot%3E%5Cn%3C%2Fdiv%3E%22%2C%22ssr%22%3Afalse%2C%22options%22%3A%7B%22mode%22%3A%22module%22%2C%22prefixIdentifiers%22%3Afalse%2C%22optimizeImports%22%3Afalse%2C%22hoistStatic%22%3Afalse%2C%22cacheHandlers%22%3Afalse%2C%22scopeId%22%3Anull%2C%22inline%22%3Afalse%2C%22ssrCssVars%22%3A%22%7B%20color%20%7D%22%2C%22bindingMetadata%22%3A%7B%22TestComponent%22%3A%22setup-const%22%2C%22setupRef%22%3A%22setup-ref%22%2C%22setupConst%22%3A%22setup-const%22%2C%22setupLet%22%3A%22setup-let%22%2C%22setupMaybeRef%22%3A%22setup-maybe-ref%22%2C%22setupProp%22%3A%22props%22%2C%22vMySetupDir%22%3A%22setup-const%22%7D%2C%22optimizeBindings%22%3Afalse%7D%7D\n * 其最终目的就是在 render 函数中调用 renderSlot 取 instance.slots 内的数据\n * TODO 这里应该是一个返回一个 block ,但是暂时还没有支持 block ，所以这个暂时只需要返回一个 vnode 即可\n * 因为 block 的本质就是返回一个 vnode\n *\n * @private\n */\nexport function renderSlot(slots, name: string, props = {}) {\n  const slot = slots[name];\n  console.log(`渲染插槽 slot -> ${name}`);\n  if (slot) {\n    // 因为 slot 是一个返回 vnode 的函数，我们只需要把这个结果返回出去即可\n    // TODO 作用域插槽的话需要绑定 ctx 到 slot 函数内，暂时不实现\n    return slot(props);\n  }\n}\n"],"names":["debug"],"mappings":"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"}